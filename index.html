<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        const updateTheme = () => {
            const theme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
            document.documentElement.setAttribute('data-bs-theme', theme);
        };
        updateTheme();
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateTheme);
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"></script>
    <title>SHA256 with RSA</title>
</head>
<body class="container-md">
    <div class="row">
        <div class="col-md-3">
            <ul class="navbar-nav flex-grow-1 my-4" style="position: fixed;">
                <li style="margin-bottom: 0.5rem;">
                    Scroll to
                </li>
                <li style="margin-bottom: 0.5rem;">
                    <a href="#generate" style="text-decoration: none;">Generate</a>
                </li>
                <li style="margin-bottom: 0.5rem;">
                    <a href="#sign" style="text-decoration: none;">Sign</a>
                </li>
                <li style="margin-bottom: 0.5rem;">
                    <a href="#verify" style="text-decoration: none;">Verify</a>
                </li>
                <li style="margin-bottom: 0.5rem;">
                    <a href="#encrypt" style="text-decoration: none;">Encrypt</a>
                </li>
                <li style="margin-bottom: 0.5rem;">
                    <a href="#decrypt" style="text-decoration: none;">Decrypt</a>
                </li>
            </ul>
        </div>
        <div class="col-md-9">
            <h1 class="my-4">SHA256 with RSA</h1>
            <div class="card my-4">
                <div class="card-header" id="generate">Generate</div>
                <div class="card-body">
                    <p><i>Generate a new RSA keypair in PEM format.</i></p>
                    <div>
                        <label>
                            Complexity
                            <input type="number" id="generate-complexity" value="2048" class="form-control" />
                        </label>
                    </div>
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Private key</th>
                                <th>Public key</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><a id="privateKeyLink" style="display: none; text-decoration: none;">Download</a></td>
                                <td><a id="publicKeyLink" style="display: none; text-decoration: none;">Download</a></td>
                            </tr>
                        </tbody>
                    </table>
                    <p id="generate-error" class="text-danger"></p>
                </div>
                <div class="card-footer">
                    <button class="btn btn-success" onclick="generate()">
                        Start
                    </button>
                    <button class="btn disabled text-success" style="display: none;" id="update_generate_msg">
                        Updated.
                    </button>
                </div>
            </div>
            <div class="card my-4">
                <div class="card-header" id="sign">Sign</div>
                <div class="card-body">
                    <p><i>Sign a message with the private key that can identify you.</i></p>
                    <div>
                        <label>
                            Private key
                            <input type="file" id="sign-private-key" class="form-control" />
                        </label>
                    </div>
                    <label for="sign-content">Message</label>
                    <textarea rows="5" id="sign-content" class="form-control"
                    placeholder="Blank spaces and new lines at the end can lead to different result."></textarea>
                    <label for="sign-signature">Signature</label>
                    <textarea rows="3" id="sign-signature" class="form-control" readonly disabled></textarea>
                    <p id="sign-error" class="text-danger"></p>
                </div>
                <div class="card-footer">
                    <button class="btn btn-success" onclick="sign()">
                        Start
                    </button>
                    <button class="btn disabled text-success" style="display: none;" id="update_sign_msg">
                        Updated.
                    </button>
                </div>
            </div>
            <div class="card my-4">
                <div class="card-header" id="verify">Verify</div>
                <div class="card-body">
                    <p><i>Verify whether the message is from corresponding private key owner.</i></p>
                    <div>
                        <label>
                            Public key
                            <input type="file" id="verify-public-key" class="form-control" />
                        </label>
                    </div>
                    <label for="verify-content">Message</label>
                    <textarea rows="5" id="verify-content" class="form-control"
                    placeholder="Blank spaces and new lines at the end can lead to different result."></textarea>
                    <label for="verify-signature">Signature</label>
                    <textarea rows="3" id="verify-signature" class="form-control"></textarea>
                    <p>Result: <span id="verify-result"></span></p>
                    <p id="verify-error" class="text-danger"></p>
                </div>
                <div class="card-footer">
                    <button class="btn btn-success" onclick="verify()">
                        Start
                    </button>
                    <button class="btn disabled text-success" style="display: none;" id="update_verify_msg">
                        Updated.
                    </button>
                </div>
            </div>
            <div class="card my-4">
                <div class="card-header" id="encrypt">Encrypt</div>
                <div class="card-body">
                    <p><i>Encrypt the message which can only be decrypted by corresponding private key.</i></p>
                    <div>
                        <label>
                            Public key
                            <input type="file" id="encrypt-public-key" class="form-control" />
                        </label>
                    </div>
                    <label for="encrypt-content">Message</label>
                    <textarea rows="5" id="encrypt-content" class="form-control"
                    placeholder="Blank spaces and new lines at the end can lead to different result."></textarea>
                    <label for="encrypt-result">Encrypted content</label>
                    <textarea rows="8" id="encrypt-result" class="form-control" readonly disabled></textarea>
                    <p id="encrypt-error" class="text-danger"></p>
                </div>
                <div class="card-footer">
                    <button class="btn btn-success" onclick="encrypt()">
                        Start
                    </button>
                    <button class="btn disabled text-success" style="display: none;" id="update_encrypt_msg">
                        Updated.
                    </button>
                </div>
            </div>
            <div class="card my-4">
                <div class="card-header" id="decrypt">Decrypt</div>
                <div class="card-body">
                    <p><i>Decrypt the message which was encrypted by the corresponding public key.</i></p>
                    <div>
                        <label>
                            Private key
                            <input type="file" id="decrypt-private-key" class="form-control" />
                        </label>
                    </div>
                    <label for="decrypt-content">Encrypted content</label>
<textarea rows="8" id="decrypt-content" class="form-control" placeholder="Paste in the following format:
{
    &quot;encrypted_session_key&quot;: &quot;...&quot;,
    &quot;nonce&quot;: &quot;...&quot;,
    &quot;encrypted_message&quot;: &quot;...&quot;
}"></textarea>
                    <label for="decrypt-result">Message</label>
                    <textarea rows="5" id="decrypt-result" class="form-control" readonly disabled></textarea>
                    <p id="decrypt-error" class="text-danger"></p>
                </div>
                <div class="card-footer">
                    <button class="btn btn-success" onclick="decrypt()">
                        Start
                    </button>
                    <button class="btn disabled text-success" style="display: none;" id="update_decrypt_msg">
                        Updated.
                    </button>
                </div>
            </div>
        </div>
    </div>
    <script>
    function arrayBufferToBase64(buffer) {
        let binary = "";
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary);
    }

    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    function createDownloadLink(keyBase64, fileName, linkId) {
        const keyBlob = new Blob([keyBase64], { type: "application/octet-stream" });
        const url = URL.createObjectURL(keyBlob);
        const link = document.getElementById(linkId);
        link.href = url;
        link.download = fileName;
        link.style.display = "inline"; // Make sure the link is visible
    }

    async function generate() {
        const n = document.getElementById("generate-complexity").value;
        const error = document.getElementById("generate-error");
        error.innerText = "";
        try {
            const keyPair = await crypto.subtle.generateKey(
                {
                    name: "RSASSA-PKCS1-v1_5",
                    modulusLength: n,
                    publicExponent: new Uint8Array([1, 0, 1]),
                    hash: "SHA-256",
                },
                true,
                ["sign", "verify"]
            );
            const privateKey = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
            const publicKey = await crypto.subtle.exportKey("spki", keyPair.publicKey);
            const privateKeyBase64 = "-----BEGIN RSA PRIVATE KEY-----\n" + arrayBufferToBase64(privateKey) + "\n-----END RSA PRIVATE KEY-----";
            const publicKeyBase64 = "-----BEGIN PUBLIC KEY-----\n" + arrayBufferToBase64(publicKey) + "\n-----BEGIN PUBLIC KEY-----";
            createDownloadLink(privateKeyBase64, "private_key.txt", "privateKeyLink");
            createDownloadLink(publicKeyBase64, "public_key.txt", "publicKeyLink");
        } catch (e) {
            error.innerText = e.toString();
            return;
        }
        const msg = document.getElementById("update_generate_msg");
        msg.style.display = "inline-block";
        setTimeout(function () {
            msg.style.display = "none";
        }, 1000);
    }

    async function sign() {
        const content = document.getElementById("sign-content").value;
        const private_key_node = document.getElementById("sign-private-key");
        const error = document.getElementById("sign-error");
        error.innerText = "";
        if (private_key_node.files.length === 0) {
            error.innerText = "Private key should not be empty.";
            return;
        }
        const reader = new FileReader();
        try {
            reader.readAsText(private_key_node.files[0]);
        } catch (e) {
            error.innerText = e.toString();
        }
        reader.onload = async function (e) {
            try {
                const private_key = e.target.result.toString();
                const private_key_obj = await crypto.subtle.importKey(
                    "pkcs8",
                    base64ToArrayBuffer(private_key.replace(/(-----(BEGIN|END) RSA PRIVATE KEY-----|\n)/g, "")),
                    {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: "SHA-256",
                    },
                    false,
                    ["sign"]
                );
                const signature = await crypto.subtle.sign(
                    "RSASSA-PKCS1-v1_5", private_key_obj, new TextEncoder().encode(content));
                document.getElementById("sign-signature").value = arrayBufferToBase64(signature);
            } catch (e) {
                error.innerText = e.toString();
            }
            const msg = document.getElementById("update_sign_msg");
            msg.style.display = "inline-block";
            setTimeout(function () {
                msg.style.display = "none";
            }, 1000);
        };
    }

    async function verify() {
        const error = document.getElementById("verify-error");
        error.innerText = "";
        const is_valid_node = document.getElementById("verify-result");
        is_valid_node.innerText = "";
        const public_key_node = document.getElementById("verify-public-key");
        if (public_key_node.files.length === 0) {
            error.innerText = "Public key should not be empty.";
            return;
        }
        const reader = new FileReader();
        try {
            reader.readAsText(public_key_node.files[0]);
        } catch (e) {
            error.innerText = e.toString();
        }
        reader.onload = async function (e) {
            try {
                const public_key = e.target.result.toString();
                const public_key_obj = await crypto.subtle.importKey(
                    "spki",
                    base64ToArrayBuffer(public_key.replace(/(-----(BEGIN|END) PUBLIC KEY-----|\n)/g, "")),
                    {
                        name: "RSASSA-PKCS1-v1_5",
                        hash: "SHA-256",
                    },
                    false,
                    ["verify"]
                );
                const signature = document.getElementById("verify-signature").value;
                const content = document.getElementById("verify-content").value;
                const is_valid = await crypto.subtle.verify(
                    "RSASSA-PKCS1-v1_5", public_key_obj, base64ToArrayBuffer(signature),
                    new TextEncoder().encode(content)
                );
                if (is_valid) {
                    is_valid_node.className = "text-success";
                    is_valid_node.innerText = "VALID";
                } else {
                    is_valid_node.className = "text-danger";
                    is_valid_node.innerText = "INVALID";
                }
            } catch (e) {
                error.innerText = e.toString();
            }
        };
        const msg = document.getElementById("update_verify_msg");
        msg.style.display = "inline-block";
        setTimeout(function () {
            msg.style.display = "none";
        }, 1000);
    }

    async function encrypt() {
        const public_key_node = document.getElementById("encrypt-public-key");
        const error = document.getElementById("encrypt-error");
        error.innerText = "";
        const encrypted_result = document.getElementById("encrypt-result");
        encrypted_result.innerHTML = "";
        if (public_key_node.files.length === 0) {
            error.innerText = "Public key should not be empty.";
            return;
        }
        const reader = new FileReader();
        try {
            reader.readAsText(public_key_node.files[0]);
        } catch (e) {
            error.innerText = e.toString();
        }
        reader.onload = async function (e) {
            try {
                const public_key = e.target.result.toString();
                const public_key_obj = await crypto.subtle.importKey(
                    "spki",
                    base64ToArrayBuffer(public_key.replace(/(-----(BEGIN|END) PUBLIC KEY-----|\n)/g, "")),
                    {
                        name: "RSA-OAEP",
                        hash: "SHA-256",
                    },
                    false,
                    ["encrypt"]
                );
                const sessionKey = crypto.getRandomValues(new Uint8Array(32));
                const encryptedSessionKey = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, public_key_obj, sessionKey);
                const content = document.getElementById("encrypt-content").value;
                const aesKey = await crypto.subtle.importKey("raw", sessionKey, { name: "AES-GCM" }, false, ["encrypt"]);
                const cipherAes = await crypto.subtle.encrypt(
                    {
                        name: "AES-GCM",
                        iv: sessionKey.slice(0, 12), // 12-byte nonce for AES-GCM
                    },
                    aesKey,
                    new TextEncoder().encode(content)
                );
                encrypted_result.innerHTML = JSON.stringify(
                    {
                        encrypted_session_key: arrayBufferToBase64(encryptedSessionKey),
                        nonce: arrayBufferToBase64(sessionKey.slice(0, 12)),
                        encrypted_message: arrayBufferToBase64(cipherAes),
                    },
                    null,
                    4
                );
            } catch (e) {
                error.innerText = e.toString();
            }
        };
        const msg = document.getElementById("update_encrypt_msg");
        msg.style.display = "inline-block";
        setTimeout(function () {
            msg.style.display = "none";
        }, 1000);
    }

    async function decrypt() {
        const content = document.getElementById("decrypt-content").value;
        const private_key_node = document.getElementById("decrypt-private-key");
        const error = document.getElementById("decrypt-error");
        error.innerText = "";
        if (private_key_node.files.length === 0) {
            error.innerText = "Private key should not be empty.";
            return;
        }
        const reader = new FileReader();
        try {
            reader.readAsText(private_key_node.files[0]);
        } catch (e) {
            error.innerText = e.toString();
        }
        const message_node = document.getElementById("decrypt-result");
        message_node.innerHTML = "";
        reader.onload = async function (e) {
            try {
                const private_key = e.target.result.toString();
                const private_key_obj = await crypto.subtle.importKey(
                    "pkcs8",
                    base64ToArrayBuffer(private_key.replace(/(-----(BEGIN|END) RSA PRIVATE KEY-----|\n)/g, "")),
                    {
                        name: "RSA-OAEP",
                        hash: "SHA-256",
                    },
                    false,
                    ["decrypt"]
                );
                const parsedContent = JSON.parse(content);
                const encryptedSessionKey = base64ToArrayBuffer(parsedContent.encrypted_session_key);
                const sessionKey = await crypto.subtle.decrypt({ name: "RSA-OAEP" }, private_key_obj, encryptedSessionKey);
                const cipherAes = await crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: base64ToArrayBuffer(parsedContent.nonce),
                    },
                    await crypto.subtle.importKey("raw", sessionKey, { name: "AES-GCM" }, false, ["decrypt"]),
                    base64ToArrayBuffer(parsedContent.encrypted_message)
                );
                message_node.innerHTML = new TextDecoder().decode(cipherAes);
            } catch (e) {
                error.innerText = e.toString();
            }
        };
        const msg = document.getElementById("update_decrypt_msg");
        msg.style.display = "inline-block";
        setTimeout(function () {
            msg.style.display = "none";
        }, 1000);
    }
    </script>
</body>
</html>
